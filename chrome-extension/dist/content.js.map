{"version":3,"file":"content.js","mappings":"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","sources":["webpack://pastehuman-extension/./src/content.js"],"sourcesContent":["// Track the current typing session\nlet currentTypingSession = null;\n\n/**\n * Check if an element can accept text input\n * @param {Element} element - The element to check\n * @returns {boolean} - Whether the element can accept text\n */\nfunction canAcceptText(element) {\n    if (!element) return false;\n    \n    if (element.isContentEditable) return true;\n    \n    if (element.tagName === 'TEXTAREA') return true;\n    \n    if (element.tagName === 'INPUT') {\n        const type = element.type.toLowerCase();\n        return ['text', 'search', 'url', 'email', 'password', 'tel'].includes(type);\n    }\n    \n    return false;\n}\n\n/**\n * Insert text using modern APIs with fallbacks\n * @param {Element} element - The target element\n * @param {string} text - The text to insert\n */\nfunction insertTextModern(element, text) {\n    if (element.isContentEditable) {\n        // Try modern approach first\n        if (document.queryCommandSupported && document.queryCommandSupported('insertText')) {\n            const success = document.execCommand('insertText', false, text);\n            if (success) {\n                // Dispatch input event for contenteditable\n                const inputEvent = new InputEvent('input', {\n                    bubbles: true,\n                    cancelable: true,\n                    inputType: 'insertText',\n                    data: text\n                });\n                element.dispatchEvent(inputEvent);\n                return;\n            }\n        }\n        \n        // Fallback for contenteditable\n        const selection = window.getSelection();\n        if (selection.rangeCount > 0) {\n            const range = selection.getRangeAt(0);\n            range.deleteContents();\n            range.insertNode(document.createTextNode(text));\n            range.collapse(false);\n            selection.removeAllRanges();\n            selection.addRange(range);\n            \n            // Dispatch input event\n            const inputEvent = new InputEvent('input', {\n                bubbles: true,\n                cancelable: true,\n                inputType: 'insertText',\n                data: text\n            });\n            element.dispatchEvent(inputEvent);\n        }\n    } else if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {\n        const startPos = element.selectionStart || 0;\n        const endPos = element.selectionEnd || 0;\n        const currentValue = element.value || '';\n        \n        // Insert the text at the cursor position\n        element.value = \n            currentValue.substring(0, startPos) + \n            text + \n            currentValue.substring(endPos, currentValue.length);\n        \n        // Update cursor position\n        const newPos = startPos + text.length;\n        element.setSelectionRange(newPos, newPos);\n        \n        // Dispatch input event\n        const inputEvent = new InputEvent('input', {\n            bubbles: true,\n            cancelable: true,\n            inputType: 'insertText',\n            data: text\n        });\n        element.dispatchEvent(inputEvent);\n        \n        // Also dispatch change event for better compatibility\n        const changeEvent = new Event('change', { bubbles: true });\n        element.dispatchEvent(changeEvent);\n    }\n}\n\n/**\n * Split text into typing chunks (preserving whitespace)\n * @param {string} text - The text to split\n * @returns {string[]} - Array of text chunks\n */\nfunction splitTextIntoChunks(text) {\n    // Split on word boundaries while preserving whitespace\n    return text.split(/(\\s+)/).filter(chunk => chunk.length > 0);\n}\n\n/**\n * Clean up typing session\n */\nfunction cleanup() {\n    currentTypingSession = null;\n}\n\n/**\n * Emulates human-like typing in the active element\n * @param {string} text - The text to type\n * @param {string|number} session - The session ID to track this typing session\n * @param {boolean} [delayedStart=false] - Whether to delay the start of typing\n */\nfunction emulateTyping(text, session, delayedStart = false) {\n    const activeElement = document.activeElement;\n    \n    // Validate the active element\n    if (!canAcceptText(activeElement)) {\n        console.warn('Active element cannot accept text input');\n        return;\n    }\n    \n    // Use default text if none provided (for testing)\n    const textToType = text || 'This is a test of human-like typing. ';\n    \n    // Split text into chunks for more natural typing\n    const chunks = splitTextIntoChunks(textToType);\n    let currentChunkIndex = 0;\n    \n    // Store the current session\n    currentTypingSession = session;\n    \n    // Function to type the next chunk\n    function typeNextChunk() {\n        // Check if we should still be typing in this session\n        if (currentChunkIndex >= chunks.length || currentTypingSession !== session) {\n            return;\n        }\n        \n        // Get the current chunk\n        const chunk = chunks[currentChunkIndex];\n        \n        try {\n            // Ensure the element is still focused and valid\n            if (document.activeElement !== activeElement || !canAcceptText(activeElement)) {\n                console.warn('Active element changed during typing session');\n                cleanup();\n                return;\n            }\n            \n            // Insert the text chunk\n            insertTextModern(activeElement, chunk);\n            \n            currentChunkIndex++;\n            \n            // Calculate a random delay based on chunk type\n            let delay;\n            if (/^\\s+$/.test(chunk)) {\n                // Shorter delay for whitespace\n                delay = Math.random() * 200 + 100;\n            } else {\n                // Longer delay for words (200-800ms)\n                delay = Math.random() * 600 + 200;\n            }\n            \n            // Schedule the next chunk if we're still in the same session\n            if (currentTypingSession === session && currentChunkIndex < chunks.length) {\n                setTimeout(typeNextChunk, delay);\n            } else if (currentChunkIndex >= chunks.length) {\n                // Typing completed\n                cleanup();\n            }\n        } catch (error) {\n            console.error('Error during typing:', error);\n            cleanup();\n        }\n    }\n    \n    // Start typing\n    if (delayedStart) {\n        // Small delay before starting to type\n        setTimeout(typeNextChunk, 1000);\n    } else {\n        typeNextChunk();\n    }\n}\n\n// Listen for messages from the background script or popup\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    try {\n        if (message.action === 'startTyping') {\n            // Validate message data\n            if (!message.text || typeof message.text !== 'string') {\n                sendResponse({ success: false, error: 'Invalid text provided' });\n                return;\n            }\n            \n            // Start a new typing session with a unique ID\n            const sessionId = Date.now() + Math.random();\n            const text = message.text;\n            const delayedStart = Boolean(message.delayedStart);\n            \n            // Start typing\n            emulateTyping(text, sessionId, delayedStart);\n            \n            // Send success response\n            sendResponse({ success: true, sessionId: sessionId });\n        } else if (message.action === 'stopTyping') {\n            // Stop current typing session\n            cleanup();\n            sendResponse({ success: true });\n        } else {\n            sendResponse({ success: false, error: 'Unknown action' });\n        }\n    } catch (error) {\n        console.error('Error handling message:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n    \n    // Return true to indicate we're sending a response\n    return true;\n});\n\n// Clean up on page unload\nwindow.addEventListener('beforeunload', cleanup);\n\n// Clean up on page hide (for better mobile support)\nwindow.addEventListener('pagehide', cleanup);\n\n// Export for testing\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { \n        emulateTyping, \n        canAcceptText, \n        splitTextIntoChunks, \n        cleanup \n    };\n}"],"names":["currentTypingSession","canAcceptText","element","isContentEditable","tagName","type","toLowerCase","includes","splitTextIntoChunks","text","split","filter","chunk","length","cleanup","emulateTyping","session","delayedStart","arguments","undefined","activeElement","document","console","warn","chunks","currentChunkIndex","typeNextChunk","delay","queryCommandSupported","execCommand","inputEvent","InputEvent","bubbles","cancelable","inputType","data","dispatchEvent","selection","window","getSelection","rangeCount","range","getRangeAt","deleteContents","insertNode","createTextNode","collapse","removeAllRanges","addRange","startPos","selectionStart","endPos","selectionEnd","currentValue","value","substring","newPos","setSelectionRange","changeEvent","Event","insertTextModern","test","Math","random","setTimeout","error","chrome","runtime","onMessage","addListener","message","sender","sendResponse","action","success","sessionId","Date","now","Boolean","addEventListener","module","exports"],"sourceRoot":""}