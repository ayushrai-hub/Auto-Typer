{"version":3,"file":"background.js","mappings":"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","sources":["webpack://pastehuman-extension/./src/background.js"],"sourcesContent":["// Store typing sessions for cleanup\nconst activeSessions = new Map();\n\n// Listen for when the extension is installed\nchrome.runtime.onInstalled.addListener(() => {\n  createContextMenus();\n  setupKeyboardShortcuts();\n});\n\n// Create context menu items\nfunction createContextMenus() {\n  // Remove existing menus first (for updates)\n  chrome.contextMenus.removeAll(() => {\n    // Create parent menu item\n    chrome.contextMenus.create({\n      id: 'pasteHuman',\n      title: 'Paste as Human',\n      contexts: ['editable']\n    });\n\n    // Child menu items\n    chrome.contextMenus.create({\n      id: 'pasteHumanNormal',\n      parentId: 'pasteHuman',\n      title: 'Start Immediately',\n      contexts: ['editable']\n    });\n\n    chrome.contextMenus.create({\n      id: 'pasteHumanDelayed',\n      parentId: 'pasteHuman',\n      title: 'With Delayed Start (1s)',\n      contexts: ['editable']\n    });\n\n    chrome.contextMenus.create({\n      id: 'pasteHumanCustom',\n      parentId: 'pasteHuman',\n      title: 'Custom Text...',\n      contexts: ['editable']\n    });\n\n    // Separator\n    chrome.contextMenus.create({\n      id: 'separator1',\n      parentId: 'pasteHuman',\n      type: 'separator',\n      contexts: ['editable']\n    });\n\n    chrome.contextMenus.create({\n      id: 'stopTyping',\n      parentId: 'pasteHuman',\n      title: 'Stop Current Typing',\n      contexts: ['editable']\n    });\n  });\n}\n\n// Setup keyboard shortcuts\nfunction setupKeyboardShortcuts() {\n  // Register commands if they exist in manifest\n  chrome.commands?.onCommand?.addListener((command) => {\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n      if (tabs[0]) {\n        switch (command) {\n          case 'paste-human':\n            handlePasteHuman(tabs[0].id, false);\n            break;\n          case 'paste-human-delayed':\n            handlePasteHuman(tabs[0].id, true);\n            break;\n          case 'stop-typing':\n            handleStopTyping(tabs[0].id);\n            break;\n        }\n      }\n    });\n  });\n}\n\nconst OFFSCREEN_DOCUMENT_PATH = '/offscreen.html';\nlet creating;\n\nasync function hasOffscreenDocument(path) {\n  const offscreenUrl = chrome.runtime.getURL(path);\n  const clients = await self.clients.matchAll();\n  return clients.some(client => client.url === offscreenUrl);\n}\n\nasync function setupOffscreenDocument(path) {\n  if (await hasOffscreenDocument(path)) {\n    return;\n  }\n  if (creating) {\n    await creating;\n  } else {\n    creating = chrome.offscreen.createDocument({\n      url: path,\n      reasons: ['CLIPBOARD'],\n      justification: 'The extension needs to read clipboard text in the background.',\n    });\n    await creating;\n    creating = null;\n  }\n}\n\nasync function getClipboardText() {\n  await setupOffscreenDocument(OFFSCREEN_DOCUMENT_PATH);\n  const response = await chrome.runtime.sendMessage({ type: 'get-clipboard-text' });\n  await chrome.offscreen.closeDocument();\n  return response;\n}\n\n// Handle paste as human functionality\nasync function handlePasteHuman(tabId, delayedStart = false, customText = null) {\n  try {\n    let textToPaste = customText;\n    \n    // If no custom text, try to get from clipboard\n    if (!textToPaste) {\n      textToPaste = await getClipboardText();\n    }\n    \n    // If still no text, use default test text\n    if (!textToPaste || textToPaste.trim() === '') {\n      textToPaste = 'This is a test of human-like typing functionality.';\n      showNotification('No clipboard text found, using default text', 'info');\n    }\n    \n    // Send message to content script\n    const response = await chrome.tabs.sendMessage(tabId, {\n      action: 'startTyping',\n      text: textToPaste,\n      delayedStart: delayedStart\n    });\n    \n    if (response && response.success) {\n      // Store session for potential cleanup\n      activeSessions.set(tabId, response.sessionId);\n      \n      const message = delayedStart \n        ? 'Human typing will start in 1 second...' \n        : 'Human typing started!';\n      showNotification(message, 'success');\n    } else {\n      throw new Error(response?.error || 'Unknown error occurred');\n    }\n    \n  } catch (error) {\n    console.error('Error in handlePasteHuman:', error);\n    \n    // Handle specific error cases\n    if (error.message.includes('Could not establish connection')) {\n      showNotification('Please refresh the page and try again', 'error');\n    } else if (error.message.includes('No active element')) {\n      showNotification('Please click in a text field first', 'warning');\n    } else {\n      showNotification(`Error: ${error.message}`, 'error');\n    }\n  }\n}\n\n// Handle stop typing functionality\nasync function handleStopTyping(tabId) {\n  try {\n    const response = await chrome.tabs.sendMessage(tabId, {\n      action: 'stopTyping'\n    });\n    \n    if (response && response.success) {\n      activeSessions.delete(tabId);\n      showNotification('Typing stopped', 'info');\n    }\n  } catch (error) {\n    console.error('Error stopping typing:', error);\n    showNotification('Could not stop typing', 'error');\n  }\n}\n\n// Function to show notifications\nfunction showNotification(message, type = 'info') {\n  const notificationId = `human-typing-${Date.now()}`;\n  \n  // Choose icon based on type\n  const iconPath = {\n    success: 'icons/icon48.png',\n    error: 'icons/icon48.png',\n    warning: 'icons/icon48.png',\n    info: 'icons/icon48.png'\n  }[type] || 'icons/icon48.png';\n  \n  chrome.notifications.create(notificationId, {\n    type: 'basic',\n    iconUrl: iconPath,\n    title: 'Human Typing',\n    message: message,\n    priority: type === 'error' ? 2 : 1\n  });\n  \n  // Auto-clear notification after a few seconds\n  setTimeout(() => {\n    chrome.notifications.clear(notificationId);\n  }, 3000);\n}\n\n// Prompt for custom text\nasync function promptForCustomText(tabId, delayedStart = false) {\n  // Since we can't use prompt() in background script, we'll open a simple popup\n  // or use chrome.windows.create with a small HTML page\n  \n  try {\n    // For now, we'll create a simple approach using chrome.windows\n    const window = await chrome.windows.create({\n      url: chrome.runtime.getURL('prompt.html'),\n      type: 'popup',\n      width: 400,\n      height: 200,\n      focused: true\n    });\n    \n    // Store the context for when the prompt responds\n    chrome.storage.local.set({\n      [`prompt_${window.id}`]: {\n        tabId: tabId,\n        delayedStart: delayedStart,\n        timestamp: Date.now()\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error creating prompt window:', error);\n    showNotification('Could not open custom text prompt', 'error');\n  }\n}\n\n// Listen for context menu clicks\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  switch (info.menuItemId) {\n    case 'pasteHumanNormal':\n      await handlePasteHuman(tab.id, false);\n      break;\n      \n    case 'pasteHumanDelayed':\n      await handlePasteHuman(tab.id, true);\n      break;\n      \n    case 'pasteHumanCustom':\n      await promptForCustomText(tab.id, false);\n      break;\n      \n    case 'stopTyping':\n      await handleStopTyping(tab.id);\n      break;\n  }\n});\n\n// Handle messages from other parts of the extension\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  switch (message.action) {\n    case 'customTextSubmit':\n      if (message.text && message.context) {\n        handlePasteHuman(\n          message.context.tabId, \n          message.context.delayedStart, \n          message.text\n        );\n        sendResponse({ success: true });\n      } else {\n        sendResponse({ success: false, error: 'Invalid custom text data' });\n      }\n      break;\n      \n    case 'getClipboard':\n      getClipboardText().then(text => {\n        sendResponse({ success: true, text: text });\n      }).catch(error => {\n        sendResponse({ success: false, error: error.message });\n      });\n      return true; // Async response\n      \n    default:\n      sendResponse({ success: false, error: 'Unknown action' });\n  }\n});\n\n// Clean up when tabs are closed\nchrome.tabs.onRemoved.addListener((tabId) => {\n  activeSessions.delete(tabId);\n});\n\n// Clean up old prompt contexts\nchrome.windows.onRemoved.addListener((windowId) => {\n  chrome.storage.local.remove(`prompt_${windowId}`);\n});\n\n// Periodic cleanup of old sessions\nsetInterval(() => {\n  const now = Date.now();\n  const maxAge = 5 * 60 * 1000; // 5 minutes\n  \n  chrome.storage.local.get(null, (items) => {\n    Object.keys(items).forEach(key => {\n      if (key.startsWith('prompt_') && items[key].timestamp) {\n        if (now - items[key].timestamp > maxAge) {\n          chrome.storage.local.remove(key);\n        }\n      }\n    });\n  });\n}, 60000); // Run every minute"],"names":["activeSessions","Map","chrome","runtime","onInstalled","addListener","_chrome$commands","contextMenus","removeAll","create","id","title","contexts","parentId","type","commands","onCommand","command","tabs","query","active","currentWindow","handlePasteHuman","handleStopTyping","OFFSCREEN_DOCUMENT_PATH","creating","async","getClipboardText","path","_context","offscreenUrl","getURL","_matchAllInstanceProperty","self","clients","call","some","client","url","hasOffscreenDocument","offscreen","createDocument","reasons","justification","setupOffscreenDocument","response","sendMessage","closeDocument","tabId","delayedStart","arguments","length","undefined","customText","textToPaste","_trimInstanceProperty","showNotification","action","text","success","Error","error","set","sessionId","console","message","includes","concat","delete","notificationId","Date","now","iconPath","warning","info","notifications","iconUrl","priority","setTimeout","clear","onClicked","tab","menuItemId","window","windows","width","height","focused","storage","local","timestamp","promptForCustomText","onMessage","sender","sendResponse","context","then","catch","onRemoved","windowId","remove","setInterval","get","items","Object","keys","forEach","key","startsWith"],"sourceRoot":""}